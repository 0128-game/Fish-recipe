<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>魚料理レシピ一覧</title>
<style>
:root{
  --bg:#f6f7fb;
  --card:#ffffff;
  --accent:#2b6cb0;
  --muted:#666;
  --success:#2f855a;
  --danger:#c53030;
  --max-width:1200px;
}
*{box-sizing:border-box}
body{
  font-family: "Hiragino Kaku Gothic ProN", "Yu Gothic", "Meiryo",sans-serif;
  margin:0;
  background:var(--bg);
  color:#222;
  padding:20px;
  display:flex;
  justify-content:center;
}
.wrap{
  width:100%;
  max-width:var(--max-width);
}
header{
  display:flex;
  gap:12px;
  align-items:flex-end;
  margin-bottom:18px;
}
header h1{margin:0;font-size:1.3rem}
.controls{
  margin-left:auto;
  display:flex;
  gap:8px;
  flex-wrap:wrap;
  align-items:center;
}
input[type="search"], select{
  padding:8px 10px;
  border-radius:8px;
  border:1px solid #d6d8df;
  background:var(--card);
}
button{
  padding:8px 12px;
  border-radius:8px;
  border:none;
  background:var(--accent);
  color:white;
  cursor:pointer;
}
button:disabled{opacity:.6;cursor:not-allowed}
main{
  background:transparent;
}
/* ★★★ hidden クラス: 要素を完全に非表示にする ★★★ */
.hidden {
    display: none !important;
}
/* --- 画面切り替えのコアCSSルール --- */

/* リスト表示時 (.wrapに.list-viewクラスがある場合) */
.wrap.list-view header {
    display: flex; /* ヘッダー（検索、絞り込み）を表示 */
}
.wrap.list-view #recipeTable {
    display: table; /* レシピ一覧テーブルを表示 */
}
.wrap.list-view #message {
    display: block; /* メッセージ/件数表示を表示 */
}
.wrap.list-view #detailContainer {
    display: none !important; /* 詳細コンテナを非表示 */
}

/* 詳細表示時 (.wrapに.detail-viewクラスがある場合) */
.wrap.detail-view header,
.wrap.detail-view #recipeTable,
.wrap.detail-view #message {
    display: none !important; /* リスト表示に必要な要素を全て非表示 */
}
.wrap.detail-view #detailContainer {
    display: block !important; /* 詳細コンテナを確実に表示 */
}
.detail-view header {
    display: none; /* リストヘッダーを非表示 */
}
.detail-view table {
    display: none; /* テーブルを非表示 */
}


table{
  width:100%;
  border-collapse:collapse;
  background:var(--card);
  border-radius:10px;
  overflow:hidden;
  box-shadow:0 6px 18px rgba(20,20,40,0.06);
}
thead th{
  text-align:left;
  padding:10px 12px;
  font-size:0.85rem;
  background:#f1f5f9;
  border-bottom:1px solid #eee;
  position:sticky;
  top:0;
  z-index:1;
}
/* tbody tdのスタイルをPicture列表示用に上書き・調整 */
tbody td{
  padding:10px 12px;
  border-bottom:1px dashed #eee;
  vertical-align:top;
  font-size:0.95rem;
  text-align: center;
}
/* 画像がある列（3番目）以外は左寄せに戻す */
tbody td:nth-child(1), /* No */
tbody td:nth-child(2), /* Type */
tbody td:nth-child(4), /* Title / flavortxt */
tbody td:nth-child(5), /* 魚 / 旬 */
tbody td:nth-child(6), /* 難易度 / 時間 */
tbody td:nth-child(7), /* 費用 / その他情報 */
tbody td:nth-child(8){ /* 操作 */
  text-align: left;
}
tbody tr:hover{background:rgba(43,108,176,0.03)}
.muted{color:var(--muted);font-size:0.85rem}
.pill{display:inline-block;padding:4px 8px;border-radius:999px;background:#eef5ff;color:var(--accent);font-size:0.8rem}

/* ★ 下処理ボタンのスタイルを強調 (最終調整版) ★ */
.pre-link-pill {
    /* 基礎デザインの調整 */
    background-color: #48bb78 !important; /* 目立つ明るいグリーン */
    color: white !important; /* テキストを白にしてコントラストを確保 */
    border: 1px solid #38a169 !important;
    cursor: pointer;
    font-weight: bold;
    padding: 6px 12px; /* パディングを少し増やして押しやすく */
    
    /* ホバー時の変化を滑らかに */
    transition: all 0.2s ease-in-out; 
    
    /* リンク/ボタンであることをアピール */
    position: relative; 
    overflow: hidden; /* ホバーエフェクトの準備 */
}

/* テキストの前にアイコン/矢印を追加 */
.pre-link-pill::before {
    content: "↪"; /* 戻る/進む矢印のようなユニコード文字 */
    font-size: 1.1em;
    font-weight: 900;
    margin-right: 6px;
    display: inline-block;
}

.pre-link-pill:hover {
    /* ホバーで色が濃く沈む */
    background-color: #38a169 !important; 
    /* 強調のために影を追加 */
    box-shadow: 0 4px 10px rgba(72, 187, 120, 0.4); 
    /* スケールアップして「押せる感」を出す */
    transform: translateY(-1px);
}
/* --- 上記で下処理ボタンのスタイル終了 --- */


.actions button{margin-right:6px}
.tag-type{padding:4px 8px;border-radius:6px;font-size:0.8rem}
.type-recipe{background:#fff7ed;color:#b45309;border:1px solid #f6e7d0}
.type-pre{background:#f0fff4;color:#2f855a;border:1px solid #d6f7df}
/* Picture列の画像スタイル: 80px */
.recipe-thumb{
  width: 80px;
  height: 80px;
  object-fit: cover;
  border-radius: 4px;
  display: block;
  margin: 0 auto;
  border: 1px solid #eee;
}

/* --- 詳細コンテナ（DOM操作で表示する領域）のスタイル --- */
.detail-container{
    margin-top: 0; 
    padding: 20px;
    background: var(--card);
    border-radius: 10px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.08);
}
.detail-header{
    border-bottom: 1px solid #eee;
    padding-bottom: 15px;
    margin-bottom: 15px;
}
.detail-header h2{
    margin: 0 0 5px 0;
    font-size: 1.6rem;
    color: var(--accent);
}
.meta{
    display: flex;
    gap: 12px;
    flex-wrap: wrap;
    margin-top: 10px;
    font-size: 0.9rem;
    color: var(--muted);
}
/* 材料・道具セクションは横2列で固定 */
.detail-grid{
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 20px;
}
.section-title{
    font-size: 1.1rem;
    font-weight: 700;
    color: #222;
    margin: 10px 0 6px 0;
}
.detail-section ul, .detail-section ol{
    padding-left: 20px;
    margin-top: 5px;
}
.detail-section pre{
    white-space: pre-wrap;
    background: #f8fafc;
    padding: 10px;
    border-radius: 8px;
    border: 1px solid #eef2f7;
}
@media (max-width:700px){
    .detail-grid{grid-template-columns:1fr}
}
/* リストに戻るボタンのスタイル */
.back-button {
    background: var(--muted);
    color: white;
    padding: 8px 12px;
    border-radius: 8px;
    margin-bottom: 15px;
    float: right; 
}
/* floatを解除 */
.detail-header::after {
    content: "";
    display: table;
    clear: both;
}

/* ★★★ 材料・道具の画像ボックスを大きく表示 ★★★ */
.detail-picture-box {
    margin: 10px 0 15px 0;
    text-align: center;
    border: 1px solid #eef;
    padding: 8px;
    border-radius: 8px;
    background: #fcfcfc;
}
.detail-picture-box img {
    max-width: 100%;
    max-height: 200px; /* JSで設定する最大高さ */
    width: auto;
    object-fit: contain;
    border-radius: 4px;
    display: block;
    margin: 0 auto;
}


/* ★★★ 手順セクションの3列グリッドレイアウト ★★★ */
.recipe-steps-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr); /* 1:1:1 の3列 */
    gap: 20px; /* セクション間の間隔 */
    margin-top: 15px;
}
/* 各手順のカードスタイル */
.recipe-step-card {
    background: #f7f9fc;
    border: 1px solid #eef;
    padding: 15px;
    border-radius: 8px;
    display: flex;
    flex-direction: column;
}
.recipe-step-card ol {
    padding-left: 0; /* 番号付きリストのインデントをリセット */
    margin-top: 10px;
    list-style: none; /* olのデフォルト番号を消す */
}
/* 手順番号 (li) のスタイル調整 */
.recipe-step-card li {
    list-style-type: none; /* デフォルトの番号を消す */
    margin-bottom: 10px;
    font-weight: normal; /* テキストは通常に戻す */
}
.recipe-step-card li::before {
    content: attr(data-step) ". "; /* カスタムの番号を表示 */
    color: var(--accent);
    font-size: 1.1rem;
    font-weight: 900;
    margin-right: 5px;
}

/* 手順画像のスタイル */
.recipe-step-picture {
    margin: 0 0 10px 0; /* カード内で下にのみマージン */
    text-align: center;
}
.recipe-step-picture img {
    max-width: 100%;
    max-height: 150px; /* 3列に収まりやすい高さ */
    width: auto;
    object-fit: contain;
    border-radius: 4px;
    border: 1px dashed #eee;
}

/* モバイル対応 (3列から1列に戻す) */
@media (max-width: 900px) {
    .recipe-steps-grid {
        grid-template-columns: 1fr; /* 画面が狭いときは1列にする */
    }
}
  
.notice{padding:12px;border-radius:8px;background:#fff3f3;color:var(--danger);border:1px solid rgba(197,48,48,0.12);margin-bottom:12px}
</style>

<div class="wrap" id="wrap">
    <header>
        <h1>魚のレシピリスト</h1>
        <div class="controls">
            <input type="search" id="q" placeholder="タイトル, 材料, 魚名などで検索">
            <select id="filterType">
                <option value="all">全て</option>
                <option value="recipe">レシピ</option>
                <option value="pre">下処理</option>
            </select>
            
            <select id="filterFish">
                <option value="all">魚種: 全て</option>
                </select>
            
            <select id="filterDifficulty">
                <option value="all">難易度: 全て</option>
                <option value="1">難易度: 1以下</option>
                <option value="2">難易度: 2以下</option>
                <option value="3">難易度: 3以下</option>
                <option value="4">難易度: 4以下</option>
                <option value="5">難易度: 5以下</option>
            </select>
            
            <div style="display:inline-flex; align-items:center; gap:4px;">
                <input type="number" id="filterTime" placeholder="時間" style="width:70px; text-align:right;" min="0">
                <span>分以内</span>
            </div>
            
            <div style="display:inline-flex; align-items:center; gap:4px;">
                <input type="number" id="filterCost" placeholder="費用" style="width:70px; text-align:right;" min="0">
                <span>円以内</span>
            </div>
            
            <select id="sortBy">
                <option value="-No">No順 (降順)</option>
                <option value="No">No順 (昇順)</option>
                <option value="-difficulty">難易度 (高順)</option>
                <option value="difficulty">難易度 (低順)</option>
                <option value="-cost">費用 (高順)</option>
                <option value="cost">費用 (低順)</option>
                <option value="-time">時間 (長順)</option>
                <option value="time">時間 (短順)</option>
                <option value="title">タイトル</option>
            </select>
            <button id="reloadBtn">データ再読み込み</button>
        </div>
    </header>

    <main id="app">
        <p id="message" class="muted">データを読み込み中です...</p>
        
        <table id="recipeTable">
            <thead>
                <tr>
                    <th style="width:80px">No</th>
                    <th style="width:80px">Type</th>
                    <th style="width:80px">Picture</th> 
                    <th>Title / flavortxt</th>
                    <th style="width:160px">魚 / 旬</th>
                    <th style="width:120px">難易度 / 時間</th>
                    <th style="width:120px">費用 / その他情報</th>
                    <th style="width:110px">操作</th>
                </tr>
            </thead>
            <tbody id="tbody">
                </tbody>
        </table>

        <div id="detailContainer" class="detail-container hidden">
            <div class="detail-header">
                <button id="backToListBtn" class="back-button">← リストに戻る</button>
                <h2 id="detailTitle"></h2>
                <div id="detailSubtitle" class="muted"></div>
                <div id="detailImageContainer" style="text-align: center; margin-bottom: 15px;"></div>
                <div id="detailMeta" class="meta"></div>
            </div>
            
            <div class="detail-grid">
                <div class="detail-section">
                    <h3 class="section-title">材料 (Ingredients)</h3>
                    <div id="detailIngredients"></div>
                </div>
                <div class="detail-section" id="propsSection">
                    <h3 class="section-title">道具 (Props)</h3>
                    <div id="detailProps"></div>
                </div>
                <div class="detail-section">
                    <h3 class="section-title">下処理・調理法 (Recipe / Pre-Process)</h3>
                    <div id="detailRecipe"></div>
                </div>
            </div>
            
            <div class="detail-section">
                <h3 class="section-title">メモ (Memo)</h3>
                <div id="detailMemo"></div>
            </div>
        </div>
    </main>
</div>

<script>
/*
  expectations:
   - JSON is an object with keys: "recipes" and "preparations"
   - We'll attempt several common paths to find the JSON on GitHub Pages.
   - Defensive coding: many fields may be missing; we'll fallback to sensible defaults.
*/

(function(){
    const tryPaths = [
        'docs/recipes.json',
        './docs/recipes.json',
        '/recipes.json',
        './recipes.json'
    ];

    const wrap = document.getElementById('wrap');
    const tbody = document.getElementById('tbody');
    const qInput = document.getElementById('q');
    const filterType = document.getElementById('filterType');
    const sortBy = document.getElementById('sortBy');
    const reloadBtn = document.getElementById('reloadBtn');
    const message = document.getElementById('message');

    // ★★★ 新しいフィルター要素の定義 ★★★
    const filterFish = document.getElementById('filterFish'); 
    const filterDifficulty = document.getElementById('filterDifficulty');
    const filterTime = document.getElementById('filterTime');
    const filterCost = document.getElementById('filterCost');

    // 詳細コンテナの要素
    const detailContainer = document.getElementById('detailContainer');
    const detailTitle = document.getElementById('detailTitle');
    const detailSubtitle = document.getElementById('detailSubtitle');
    const detailImageContainer = document.getElementById('detailImageContainer');
    const detailMeta = document.getElementById('detailMeta');
    const detailIngredients = document.getElementById('detailIngredients');
    const detailRecipe = document.getElementById('detailRecipe');
    const detailMemo = document.getElementById('detailMemo');
    const backToListBtn = document.getElementById('backToListBtn'); 
    const detailProps = document.getElementById('detailProps');
    const propsSection = document.getElementById('propsSection'); 
    
    let rawData = null;
    let flatList = []; // merged list with type annotation
    let currentRawPath = null;
    
    // ★★★ 画面切り替えのコア関数 ★★★
    function showList(){
        wrap.classList.remove('detail-view');
        wrap.classList.add('list-view');
        window.scrollTo({ top: 0, behavior: 'smooth' });
    }

    function showDetail(){
        wrap.classList.remove('list-view');
        wrap.classList.add('detail-view');
        window.scrollTo({ top: 0, behavior: 'smooth' });
    }

    // Utility: safe text node creation
    function elText(tag, text, cls){
        const el = document.createElement(tag);
        if (cls) el.className = cls;
        el.textContent = (text === undefined || text === null) ? '' : String(text);
        return el;
    }

    // Try fetching from multiple paths in order
    async function fetchAny(paths){
        for (const p of paths){
            try {
                const res = await fetch(p, {cache: "no-store"});
                if (!res.ok) continue;
                const json = await res.json();
                currentRawPath = p;
                return json;
            } catch(e){
                // continue to next path
                console.warn('fetch failed for', p, e);
            }
        }
        throw new Error('recipes.json を見つけられませんでした。期待する場所: ' + paths.join(', '));
    }

    // Normalize and flatten recipes + preparations into an array for table
    function buildFlatList(data){
        const list = [];
        if (!data || typeof data !== 'object') return list;

        // recipes
        const recipes = data.recipes || {};
        for (const key of Object.keys(recipes)){
            const item = Object.assign({}, recipes[key]);
            item._type = 'recipe';
            // ensure No is string
            item.No = item.No != null ? String(item.No) : String(key);
            item._origKey = key;
            list.push(item);
        }
        // preparations
        const pres = data.preparations || {};
        for (const key of Object.keys(pres)){
            const item = Object.assign({}, pres[key]);
            item._type = 'pre';
            item.No = item.No != null ? String(item.No) : String(key);
            item._origKey = key;
            list.push(item);
        }
        return list;
    }

    // safe join array-like fields for display
    function joinIfArray(val){
        if (Array.isArray(val)) return val.join(', ');
        if (val === undefined || val === null) return '';
        return String(val);
    }
    
    function clearTable(){ tbody.innerHTML = ''; }
    
    // 魚種のユニークリストを取得し、フィルタードロップダウンに設定する
    function populateFishFilter(list){
        // レシピアイテムからすべての魚種を抽出し、重複を排除
        const fishSet = new Set();
        list.forEach(item => {
            if (item._type === 'recipe' && Array.isArray(item['fish-name'])) {
                item['fish-name'].forEach(fish => {
                    const trimmedFish = fish.trim();
                    if (trimmedFish) {
                        fishSet.add(trimmedFish);
                    }
                });
            }
        });

        const uniqueFish = Array.from(fishSet).sort();
        
        // 既存のオプションをクリアし、「全て」を再設定
        filterFish.innerHTML = '<option value="all">魚種: 全て</option>';

        // 新しいオプションを追加
        uniqueFish.forEach(fish => {
            const option = document.createElement('option');
            option.value = fish;
            option.textContent = fish;
            filterFish.appendChild(option);
        });
    }


// render table rows from list
function renderTable(list){
    clearTable();
    if (!Array.isArray(list) || list.length === 0){
        tbody.innerHTML = '<tr><td colspan="8" class="muted" style="padding:20px;text-align:center">表示するレシピがありません。</td></tr>'; 
        return;
    }
    const fragment = document.createDocumentFragment();
    for (const item of list){
        const tr = document.createElement('tr');

        // No
        const tdNo = document.createElement('td');
        tdNo.textContent = item.No || '-';
        tr.appendChild(tdNo);

        // Type
        const tdType = document.createElement('td');
        const span = document.createElement('span');
        span.className = 'tag-type ' + (item._type === 'pre' ? 'type-pre' : 'type-recipe');
        span.textContent = item._type;
        tdType.appendChild(span);
        tr.appendChild(tdType);
        
        // Picture
        const tdPicture = document.createElement('td');
        const img = document.createElement('img');
        img.className = 'recipe-thumb';
        
        const firstPic = (Array.isArray(item.pictures) && item.pictures.length > 0) ? item.pictures[0] : null;
        
        let imgSrc = '';
        if (firstPic && typeof firstPic === 'string'){
            imgSrc = firstPic;
        } else {
            imgSrc = 'https://0128-game.github.io/Fish-recipe/picture/noimage.png';
        }
        
        img.src = imgSrc;
        img.alt = item.title || '画像';
        tdPicture.appendChild(img);
        tr.appendChild(tdPicture);

        // Title and flavortxt
        const tdTitle = document.createElement('td');
        const title = elText('div', item.title || '(タイトルなし)', ''); title.style.fontWeight='700';
        const flav = elText('div', item.flavortxt || '', 'muted');
        tdTitle.appendChild(title);
        tdTitle.appendChild(flav);
        tr.appendChild(tdTitle);

        // fish / season
        const tdFish = document.createElement('td');
        tdFish.appendChild(elText('div', joinIfArray(item['fish-name']) || '-', ''));
        tdFish.appendChild(elText('div', joinIfArray(item.season) || '', 'muted'));
        tr.appendChild(tdFish);

        // difficulty / time
        const tdDiff = document.createElement('td');
        tdDiff.appendChild(elText('div', '難易度: ' + (item.difficulty != null ? item.difficulty : '-')));
        tdDiff.appendChild(elText('div', '所要: ' + (item.time != null ? item.time + '分' : '-'), 'muted'));
        tr.appendChild(tdDiff);

        // cost / info line
        const tdCost = document.createElement('td');
        tdCost.appendChild(elText('div', '¥' + (item.cost != null ? item.cost : '-')));
        const infoLine = (item._type === 'recipe')
            ? ('食事: ' + (item.timing || '-'))
            : ('特徴: ' + joinIfArray(item.feature));
        tdCost.appendChild(elText('div', infoLine, 'muted'));
        tr.appendChild(tdCost);

        // actions
        const tdActions = document.createElement('td');
        tdActions.className = 'actions';
        
        // 詳細ボタンの挙動：下処理が設定されていれば、下処理へ直接遷移
        const viewBtn = document.createElement('button');
        viewBtn.textContent = '詳細';
        
        viewBtn.addEventListener('click', ()=> {
            // レシピであり、かつ下処理が設定されている場合
            if (item._type === 'recipe' && item['pre-recipe']) {
                const preRecipeNo = String(item['pre-recipe']);
                // flatListから対応する下処理アイテムを探す (Noで検索)
                const preItem = flatList.find(i => i._type === 'pre' && String(i.No) === preRecipeNo);
                
                if (preItem) {
                    // 下処理が見つかった場合、そちらの詳細画面に遷移
                    displayDetail(preItem);
                    return; // 処理を終了
                }
            }
            
            // それ以外の場合、自分の詳細画面に遷移
            displayDetail(item);
        });
        
        tdActions.appendChild(viewBtn);

        
        // 印刷ボタン
        const printBtn = document.createElement('button');
        printBtn.textContent = '印刷';
        printBtn.style.background = '#a0aec0'; // 薄いグレー
        printBtn.addEventListener('click', ()=> {
            // 詳細画面を表示してから印刷ダイアログを開く
            displayDetail(item);
            setTimeout(() => {
                window.print();
            }, 500); // 画面切り替えを待つ
        });
        tdActions.appendChild(printBtn);

        tr.appendChild(tdActions);
        fragment.appendChild(tr);
    }
    tbody.appendChild(fragment);
}

// Utility: 画像を表示するエレメントを作成する関数
function createPictureElement(src, altText, maxHeight = '250px') {
    if (!src || src === 'null' || src === '') return null;
    
    const img = document.createElement('img');
    img.src = src;
    img.alt = altText || '画像';
    
    img.style.maxWidth = '100%';
    img.style.maxHeight = maxHeight; 
    img.style.width = 'auto';
    img.style.objectFit = 'contain';
    img.style.borderRadius = '4px';
    img.style.display = 'block';
    img.style.margin = '0 auto';
    
    return img;
}

// 詳細情報を同じページ内のコンテナに表示する関数
function displayDetail(item){
    
    // 1. 画面を詳細表示に切り替える
    showDetail(); 

    // 2. 画像パスの割り当てとインデックス再定義
    const pictures = item.pictures || [];
    const thumbPic = pictures[0] || 'https://0128-game.github.io/Fish-recipe/picture/noimage.png';

    // 3. ヘッダー情報
    detailTitle.textContent = (item.title || '(タイトルなし)') + ' — No.' + item.No;
    detailSubtitle.textContent = item.flavortxt || '';

    // 4. メタ情報 
    detailMeta.innerHTML = '';
    detailMeta.appendChild(elText('div', 'タイプ: ' + (item._type || '-'), 'pill'));
    detailMeta.appendChild(elText('div', '魚: ' + joinIfArray(item['fish-name']) , 'pill'));
    detailMeta.appendChild(elText('div', '旬: ' + joinIfArray(item.season), 'pill'));
    detailMeta.appendChild(elText('div', '難易度: ' + (item.difficulty != null ? item.difficulty : '-'), 'pill'));
    detailMeta.appendChild(elText('div', '費用: ' + (item.cost != null ? '¥' + item.cost : '-'), 'pill'));
    detailMeta.appendChild(elText('div', '所要時間: ' + (item.time != null ? item.time + '分' : '-'), 'pill'));
    
    // ★ 下処理参照の処理 (Noで検索 / なし表示)
    if (item._type === 'recipe' && item['pre-recipe']) {
         const preRecipeNo = String(item['pre-recipe']); 
         
         // Noで下処理アイテムを検索
         const preItem = flatList.find(i => i._type === 'pre' && String(i.No) === preRecipeNo);
         
         if (preItem) {
             // 1. 下処理アイテムが見つかった場合 -> クリックできる緑のボタンとして表示
             const preBtn = document.createElement('button');
             preBtn.textContent = '下処理: ' + (preItem.title || preItem.No); // タイトル優先で表示
             preBtn.className = 'pill pre-link-pill'; 
             
             preBtn.addEventListener('click', ()=> displayDetail(preItem));
             detailMeta.appendChild(preBtn);
         } else {
            // 2. 下処理アイテムが見つからない場合 -> 通常の「下処理: なし」ピルを表示
            detailMeta.appendChild(elText('div', '下処理: なし', 'pill'));
         }
    } else if (item._type === 'recipe' && !item['pre-recipe']) {
        // 3. レシピだが pre-recipe が設定されていない場合 -> 通常の「下処理: なし」ピルを表示
         detailMeta.appendChild(elText('div', '下処理: なし', 'pill'));
    } else if (item._type === 'pre') {
         // 4. 自身が下処理アイテムの場合
         detailMeta.appendChild(elText('div', '下処理', 'pill'));
    }

    // 5. メイン画像 (サムネイル: pictures[0])
    detailImageContainer.innerHTML = '';
    const mainImg = createPictureElement(thumbPic, item.title, '250px');
    if (mainImg) {
        mainImg.style.border = '1px solid #ddd';
        mainImg.style.borderRadius = '8px';
        detailImageContainer.appendChild(mainImg);
    }

    // 6. 材料 (Ingredients)
    detailIngredients.innerHTML = '';
    const ing = item.ingredients || {};
    const ingPicContainer = document.createElement('div');
    ingPicContainer.className = 'detail-picture-box';
    const ingPic = createPictureElement(thumbPic, item.title + ' 材料', '200px'); 
    if (ingPic) ingPicContainer.appendChild(ingPic);
    detailIngredients.appendChild(ingPicContainer);

    if (Object.keys(ing).length === 0){
        detailIngredients.appendChild(elText('div','(材料なし)','muted'));
    } else {
        const ul = document.createElement('ul');
        for (const k of Object.keys(ing)){
            const li = document.createElement('li');
            li.textContent = k + ': ' + (ing[k] || '');
            ul.appendChild(li);
        }
        detailIngredients.appendChild(ul);
    }

    // 7. 道具 (Props)
    detailProps.innerHTML = ''; 
    const props = item.props || {};

    if (item._type === 'pre') {
        propsSection.style.display = 'block';

        const propsPicContainer = document.createElement('div');
        propsPicContainer.className = 'detail-picture-box';
        const propsPic = createPictureElement(thumbPic, item.title + ' 道具', '200px'); 
        if (propsPic) propsPicContainer.appendChild(propsPic);
        detailProps.appendChild(propsPicContainer);
        
        if (Object.keys(props).length === 0){
            detailProps.appendChild(elText('div', '(道具なし)', 'muted'));
        } else {
            const ul = document.createElement('ul');
            for (const k of Object.keys(props)){
                const li = document.createElement('li');
                li.textContent = props[k] || ''; 
                ul.appendChild(li);
            }
            detailProps.appendChild(ul);
        }
    } else {
        propsSection.style.display = 'none';
    }

    // 8. 手順 (Recipe / Pre-Process) - 3列グリッドで表示
    detailRecipe.innerHTML = '';
    const rec = item.recipe || [];
    
    if (!Array.isArray(rec) || rec.length === 0){
        detailRecipe.appendChild(elText('div','(手順なし)','muted'));
    } else {
        const gridContainer = document.createElement('div');
        gridContainer.className = 'recipe-steps-grid'; 

        for (let i = 0; i < rec.length; i++){
            const step = rec[i];
            const stepNo = i + 1;
            
            const card = document.createElement('div');
            card.className = 'recipe-step-card';

            // 1. 手順画像
            const stepPicIndex = i + 1; 
            const stepPicSrc = pictures[stepPicIndex];

            if (stepPicSrc && stepPicSrc !== 'null' && stepPicSrc !== '') {
                const picContainer = document.createElement('div');
                picContainer.className = 'recipe-step-picture';
                const stepImg = createPictureElement(stepPicSrc, `手順${stepNo}の画像`, '150px'); 
                
                if (stepImg) { 
                    picContainer.appendChild(stepImg);
                    card.appendChild(picContainer);
                }
            }
            
            // 2. 手順テキスト
            const ol = document.createElement('ol');
            const li = document.createElement('li');
            
            li.setAttribute('data-step', stepNo); 
            li.textContent = step;
            
            ol.appendChild(li);
            card.appendChild(ol);
            
            gridContainer.appendChild(card);
        }
        
        detailRecipe.appendChild(gridContainer);
    }

    // 9. メモ (Memo)
    detailMemo.innerHTML = '';
    const memo = item.memo || [];
    if (!Array.isArray(memo) || memo.length === 0){
        detailMemo.appendChild(elText('div','(メモなし)','muted'));
    } else {
        const ulm = document.createElement('ul');
        for (const m of memo){
            ulm.appendChild(elText('li', m));
        }
        detailMemo.appendChild(ulm);
    }
}
  
function applyFiltersAndRender(){
    const q = (qInput.value || '').trim().toLowerCase();
    const type = filterType.value;
    const sortVal = sortBy.value;
    
    // ★★★ 新しいフィルターの値を取得 ★★★
    const fishName = filterFish.value; 
    const diff = filterDifficulty.value;
    const maxTime = parseFloat(filterTime.value);
    const maxCost = parseFloat(filterCost.value);
    // ★★★ ここまで ★★★

    let list = flatList.slice();

    // filter by type
    if (type !== 'all') list = list.filter(i => i._type === type);

    // search across several fields 
    if (q){
        list = list.filter(item => {
            const parts = [
                item.title, item.flavortxt,
                joinIfArray(item['fish-name']),
                joinIfArray(item.feature),
                joinIfArray(item.season),
                item.No,
                // 材料のキー名（例: サバ, 味噌）
                Object.keys(item.ingredients || {}).join(' '),
                // 手順 (recipe)
                joinIfArray(item.recipe),
                // メモ (memo)
                joinIfArray(item.memo),
                // 道具 (props, preのみ)
                joinIfArray(item.props)
            ];
            const hay = parts.filter(Boolean).join(' ').toLowerCase();
            return hay.includes(q);
        });
    }

    // ★★★ 新しいフィルターロジックの適用 ★★★
    list = list.filter(item => {
        // 下処理アイテムはこれらのフィルターの対象外
        if (item._type === 'pre') return true; 

        // 魚種フィルター
        if (fishName !== 'all') {
            // item['fish-name']が配列で、かつ選択された魚種を含む場合のみtrue
            if (!Array.isArray(item['fish-name']) || !item['fish-name'].some(f => f.trim() === fishName)) {
                return false;
            }
        }
        
        // 難易度フィルター
        if (diff !== 'all') {
            const requiredDiff = parseInt(diff, 10);
            if (item.difficulty == null || parseFloat(item.difficulty) > requiredDiff) {
                return false;
            }
        }
        
        // 時間フィルター (所要時間: time)
        if (!isNaN(maxTime) && maxTime >= 0) {
            if (item.time == null || parseFloat(item.time) > maxTime) {
                return false;
            }
        }

        // 費用フィルター (cost)
        if (!isNaN(maxCost) && maxCost >= 0) {
            if (item.cost == null || parseFloat(item.cost) > maxCost) {
                return false;
            }
        }

        return true;
    });
    // ★★★ ここまで新しいフィルターロジックの適用 ★★★


    // sort
    const desc = sortVal.startsWith('-');
    const key = desc ? sortVal.slice(1) : sortVal;
    list.sort((a,b)=>{
        // numeric-aware where possible
        const av = a[key];
        const bv = b[key];
        // No の並び替えロジックの改善 (P1, P2, 1, 2)
        if (key === 'No'){
            const extractNum = (val) => {
                const s = String(val||'');
                const isPre = s.startsWith('P');
                const num = parseInt(s.replace(/^P/,'') || '0', 10);
                return isPre ? num + 0.5 : num;
            };
            const na = extractNum(av);
            const nb = extractNum(bv);
            return desc ? nb - na : na - nb;
        }
        const an = (av == null) ? Number.POSITIVE_INFINITY : Number(av);
        const bn = (bv == null) ? Number.POSITIVE_INFINITY : Number(bv);
        if (!isFinite(an) || !isFinite(bn)){
            // fallback string compare
            return desc ? String(bv).localeCompare(String(av)) : String(av).localeCompare(String(bv));
        }
        return desc ? bn - an : an - bn;
    });


    renderTable(list);
    message.textContent = `${list.length} 件の結果を表示中 (全 ${flatList.length} 件)`;
}

    // reload button
    reloadBtn.addEventListener('click', ()=> {
        loadData();
    });
    
    // リストに戻るボタンのイベントリスナー
    backToListBtn.addEventListener('click', ()=> {
        showList();
    });

    qInput.addEventListener('input', ()=> applyFiltersAndRender());
    filterType.addEventListener('change', ()=> applyFiltersAndRender());
    sortBy.addEventListener('change', ()=> applyFiltersAndRender());
    
    // ★★★ 新しいフィルターのイベントリスナー ★★★
    filterFish.addEventListener('change', ()=> applyFiltersAndRender());
    filterDifficulty.addEventListener('change', ()=> applyFiltersAndRender());
    filterTime.addEventListener('input', ()=> applyFiltersAndRender());
    filterCost.addEventListener('input', ()=> applyFiltersAndRender());
    // ★★★ ここまで ★★★


    // main loader
    async function loadData(){
        message.textContent = '読み込み中...';
        try {
            const json = await fetchAny(tryPaths);
            rawData = json;
            flatList = buildFlatList(json);
            
            // 魚種フィルターのオプションを生成
            populateFishFilter(flatList); 

            if (flatList.length === 0){
                message.innerHTML = '<div class="notice">recipes または preparations のデータが空です。docs/recipes.json を確認してください。</div>';
            } else {
                message.textContent = `読み込み完了 — 合計 ${flatList.length} 件（recipes: ${Object.keys(json.recipes||{}).length}, preparations: ${Object.keys(json.preparations||{}).length}）`;
            }
            applyFiltersAndRender();
            // データロード完了後、初期表示はリスト画面にする
            showList();
        } catch (err){
            console.error(err);
            message.innerHTML = '<div class="notice">読み込みエラー: ' + String(err.message) + '</div>';
            clearTable();
            // エラー時は詳細画面は表示しない
            wrap.classList.remove('detail-view');
        }
    }

    // initial load
    loadData();

    // Expose for debug on window
    window._recipesApp = {
        loadData,
        getRaw: ()=> rawData,
        getFlat: ()=> flatList
    };
})();
</script>
</body>
</html>
