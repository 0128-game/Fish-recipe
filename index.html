<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>魚料理レシピ一覧</title>
<style>
/* ----------------------------------------------------- */
/* 1. 基本設定と全体レイアウト */
/* ----------------------------------------------------- */
body {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
    margin: 0;
    padding: 0;
    background: #f8f9fa; /* やや明るい背景色 */
    color: #343a40;
}

#wrap {
    max-width: 1400px; /* 少し広めに設定 */
    margin: 0 auto;
    padding: 20px;
}

header {
    background: #ffffff;
    padding: 15px 25px;
    border-radius: 8px;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
    margin-bottom: 20px;
}

h1 {
    font-size: 1.8em;
    color: #007bff;
    margin-top: 0;
    margin-bottom: 10px;
}

.controls {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    align-items: center;
}

.controls input[type="search"],
.controls select,
.controls button {
    padding: 8px 12px;
    border: 1px solid #ced4da;
    border-radius: 4px;
    font-size: 1em;
}

.controls button {
    cursor: pointer;
    background-color: #007bff;
    color: white;
    border-color: #007bff;
    transition: background-color 0.2s;
}

.controls button:hover {
    background-color: #0056b3;
}

.muted {
    color: #6c757d;
    font-size: 0.9em;
}

/* ----------------------------------------------------- */
/* 2. テーブル表示 (リストビュー) */
/* ----------------------------------------------------- */
#recipeTable {
    width: 100%;
    border-collapse: separate; /* border-radiusのためにcollapseを解除 */
    border-spacing: 0;
    background: #ffffff;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
    border-radius: 8px;
    overflow: hidden; /* 角丸を適用 */
}

#recipeTable thead {
    background-color: #e9ecef;
}

#recipeTable th, #recipeTable td {
    padding: 12px 15px;
    text-align: left;
    border-bottom: 1px solid #dee2e6;
    vertical-align: middle;
}

#recipeTable th {
    font-weight: 600;
    color: #495057;
    white-space: nowrap;
}

#recipeTable tbody tr:last-child td {
    border-bottom: none;
}

.recipe-thumb {
    width: 80px;
    height: 60px;
    object-fit: cover;
    border-radius: 4px;
    display: block;
}

.tag-type {
    display: inline-block;
    padding: 3px 8px;
    border-radius: 12px;
    font-size: 0.75em;
    font-weight: bold;
    color: white;
    text-transform: uppercase;
}
.type-recipe { background-color: #28a745; } /* Green */
.type-pre { background-color: #17a2b8; } /* Cyan */

.actions button {
    padding: 5px 10px;
    margin-right: 5px;
    margin-bottom: 4px; /* Stacked look */
    cursor: pointer;
    border: 1px solid #ccc;
    border-radius: 4px;
    font-size: 0.9em;
}

/* 印刷ボタンの色を薄いグレーに戻す */
.actions button:nth-of-type(2) {
    background: #a0aec0; 
    color: white;
    border-color: #a0aec0;
}

/* ----------------------------------------------------- */
/* 3. 詳細ビュー */
/* ----------------------------------------------------- */
.detail-container {
    padding: 30px;
    background: #ffffff;
    border-radius: 8px;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
}

/* ビューの切り替え (JavaScriptでクラスを付与) */
.list-view #recipeTable, .list-view #message {
    display: table; /* table-layoutを保持 */
}
.list-view #detailContainer {
    display: none;
}
.detail-view #recipeTable, .detail-view #message {
    display: none;
}
.detail-view #detailContainer {
    display: block;
}

.detail-header {
    padding-bottom: 15px;
    border-bottom: 1px solid #dee2e6;
    margin-bottom: 20px;
    position: relative;
}

.back-button {
    float: right;
    background: #6c757d !important; /* 目立ちすぎない色 */
    color: white;
    padding: 8px 15px;
    border: none;
    border-radius: 4px;
    font-size: 1em;
    position: absolute;
    top: 0;
    right: 0;
}

.detail-header h2 {
    font-size: 1.5em;
    color: #343a40;
    margin-top: 0;
    margin-bottom: 5px;
    padding-right: 150px; /* 戻るボタンのスペースを確保 */
}

/* メタ情報 (pill) */
.meta {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    margin-top: 10px;
}

.pill {
    background: #e9ecef; /* Light gray pill background */
    color: #495057;
    padding: 4px 12px;
    border-radius: 15px;
    font-size: 0.8em;
    font-weight: 500;
    white-space: nowrap;
}

.pre-link-pill {
    background: #17a2b8 !important; 
    color: white !important;
}

/* セクションとグリッド */
.detail-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
    gap: 20px;
    margin-bottom: 20px;
}

.detail-section {
    padding: 15px;
    border: 1px solid #e9ecef;
    border-radius: 6px;
    background: #f8f9fa;
}

.section-title {
    font-size: 1.2em;
    color: #007bff;
    border-bottom: 2px solid #007bff;
    padding-bottom: 5px;
    margin-top: 0;
    margin-bottom: 10px;
}

#detailIngredients ul, 
#detailMemo ul, 
#detailProps ul {
    list-style: disc;
    padding-left: 20px;
    margin-top: 0;
}

/* レシピ手順のグリッド */
.recipe-step-card {
    border: 1px solid #dee2e6;
    padding: 10px;
    border-radius: 4px;
    background: #ffffff;
    margin-bottom: 10px; /* JSでgridを使うため、このmarginは不要な場合があるが保険で */
}

.recipe-step-card p {
    margin-top: 5px;
    line-height: 1.5;
}


/* ----------------------------------------------------- */
/* 4. モーダルスタイル (フィルターUI) */
/* ----------------------------------------------------- */
.modal-overlay {
    display: none; /* JSで 'flex' に切り替える */
    position: fixed;
    z-index: 1000;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    overflow: auto;
    background-color: rgba(0, 0, 0, 0.5); 
    justify-content: center;
    align-items: flex-start; /* 上部に寄せる */
    padding-top: 50px;
}

.modal-content {
    background-color: #ffffff;
    padding: 30px;
    border: none; 
    width: 95%;
    max-width: 800px;
    border-radius: 8px;
    box-shadow: 0 8px 16px rgba(0, 0, 0, 0.25);
}

.modal-content h2 {
    font-size: 1.5em;
    color: #007bff;
    border-bottom: 2px solid #007bff;
    padding-bottom: 10px;
    margin-top: 0;
    margin-bottom: 20px;
}

.filter-group {
    border: 1px solid #ced4da;
    padding: 15px;
    margin-bottom: 20px;
    border-radius: 6px;
    background-color: #f8f9fa;
}

.filter-group legend {
    font-weight: 700;
    padding: 0 10px;
    color: #343a40;
    font-size: 1.1em;
}

.filter-hint {
    font-size: 0.85em;
    color: #6c757d;
    margin-bottom: 10px;
}

.filter-item {
    display: inline-block;
    margin-right: 25px;
    margin-bottom: 8px;
}

.filter-item input[type="checkbox"] {
    margin-right: 5px;
}

.filter-item label {
    cursor: pointer;
    font-weight: normal;
}

.modal-footer {
    display: flex;
    justify-content: flex-end;
    gap: 10px;
    padding-top: 20px;
    border-top: 1px solid #dee2e6;
    margin-top: 10px;
}

.modal-footer button {
    padding: 10px 20px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 1em;
}

#filterClearBtn {
    background: #6c757d;
    color: white;
}

#applyFilterBtn {
    background: #007bff;
    color: white;
}
/* ----------------------------------------------------- */
</style>

<div class="wrap" id="wrap">
    <header>
        <h1>魚のレシピリスト</h1>
       <div class="controls">
            <input type="search" id="q" placeholder="タイトル, 材料, 魚名などで検索">
            
            <select id="filterType">
                <option value="all">全て</option>
                <option value="recipe">レシピ</option>
                <option value="pre">下処理</option>
            </select>
            
            <button id="filterOpenBtn">絞り込み設定</button> 
            
            <select id="sortBy">
                <option value="No" selected>No順 (昇順)</option>
                <option value="-No">No順 (降順)</option>
                <option value="-difficulty">難易度 (高順)</option>
                <option value="difficulty">難易度 (低順)</option>
                <option value="-cost">費用 (高順)</option>
                <option value="cost">費用 (低順)</option>
                <option value="-time">時間 (長順)</option>
                <option value="time">時間 (短順)</option>
                <option value="title">タイトル</option>
            </select>
            <button id="reloadBtn">データ再読み込み</button>
        </div>
    </header>

    <main id="app">
        <p id="message" class="muted">データを読み込み中です...</p>
        
        <table id="recipeTable">
            <thead>
                <tr>
                    <th style="width:80px">No</th>
                    <th style="width:80px">Type</th>
                    <th style="width:80px">Picture</th> 
                    <th>Title / flavortxt</th>
                    <th style="width:160px">魚 / 旬</th>
                    <th style="width:120px">難易度 / 時間</th>
                    <th style="width:120px">費用 / その他情報</th>
                    <th style="width:110px">操作</th>
                </tr>
            </thead>
            <tbody id="tbody">
                </tbody>
        </table>

        <div id="detailContainer" class="detail-container hidden">
            <div class="detail-header">
                <button id="backToListBtn" class="back-button">← リストに戻る</button>
                <h2 id="detailTitle"></h2>
                <div id="detailSubtitle" class="muted"></div>
                <div id="detailImageContainer" style="text-align: center; margin-bottom: 15px;"></div>
                <div id="detailMeta" class="meta"></div>
            </div>
            
            <div class="detail-grid">
                <div class="detail-section">
                    <h3 class="section-title">材料 (Ingredients)</h3>
                    <div id="detailIngredients"></div>
                </div>
                <div class="detail-section" id="propsSection">
                    <h3 class="section-title">道具 (Props)</h3>
                    <div id="detailProps"></div>
                </div>
                <div class="detail-section">
                    <h3 class="section-title">下処理・調理法 (Recipe / Pre-Process)</h3>
                    <div id="detailRecipe"></div>
                </div>
            </div>
            
            <div class="detail-section">
                <h3 class="section-title">メモ (Memo)</h3>
                <div id="detailMemo"></div>
            </div>
        </div>
    </main>
</div>

<div id="filterModal" class="modal-overlay">
    <div class="modal-content">
        <h2>絞り込み設定</h2>
        <div id="filterContent">
            </div>
        <div class="modal-footer">
            <button id="filterClearBtn">フィルター解除</button>
            <button id="applyFilterBtn" class="primary-button">適用して閉じる</button>
        </div>
    </div>
</div>

<script>
/*
 * 最終修正版: 
 * 1. UIをモーダル（ポップアップ）形式のチェックボックスに変更。
 * 2. フィルタリングロジックを、チェックボックスの複数選択（魚種）および「以下」（難易度/時間/費用）に対応させて修正。
 */

(function(){
    const tryPaths = [
        'docs/recipes.json',
        './docs/recipes.json',
        '/recipes.json',
        './recipes.json'
    ];

    // ★★★ リスト/フィルター関連の要素 (既存のHTML要素を使用) ★★★
    const wrap = document.getElementById('wrap');
    const tbody = document.getElementById('tbody');
    const qInput = document.getElementById('q');
    const filterType = document.getElementById('filterType');
    const sortBy = document.getElementById('sortBy');
    const reloadBtn = document.getElementById('reloadBtn');
    const message = document.getElementById('message');

    // ★★★ 新しいフィルターモーダル関連の要素 (HTMLへの追加が必要です) ★★★
    const filterOpenBtn = document.getElementById('filterOpenBtn'); // 絞り込みボタン
    const filterModal = document.getElementById('filterModal');     // 絞り込みモーダルコンテナ
    const filterContent = document.getElementById('filterContent'); // チェックボックスを挿入するコンテナ
    const applyFilterBtn = document.getElementById('applyFilterBtn'); // モーダル内の適用ボタン
    const filterClearBtn = document.getElementById('filterClearBtn'); // モーダル内のクリアボタン
    
    // ★★★ 詳細コンテナの要素 ★★★
    const detailTitle = document.getElementById('detailTitle');
    const detailSubtitle = document.getElementById('detailSubtitle');
    const detailImageContainer = document.getElementById('detailImageContainer');
    const detailMeta = document.getElementById('detailMeta');
    const detailIngredients = document.getElementById('detailIngredients');
    const detailRecipe = document.getElementById('detailRecipe');
    const detailMemo = document.getElementById('detailMemo');
    const backToListBtn = document.getElementById('backToListBtn');
    const detailProps = document.getElementById('detailProps');
    const propsSection = document.getElementById('propsSection');

    let rawData = null;
    let flatList = []; // merged list with type annotation
    
    // フィルタの状態を保持するオブジェクト (Setで複数選択に対応)
    let activeFilters = {
        'fish-name': new Set(),
        difficulty: new Set(), // 難易度は最大値を保持する
        time: new Set(),       // 時間は最大値を保持する
        cost: new Set()        // 費用は最大値を保持する
    };
    // 固定オプション
    const DIFFICULTY_OPTIONS = ['1', '2', '3', '4', '5'];
    const TIME_OPTIONS = [15, 30, 60, 90, 120]; 
    const COST_OPTIONS = [500, 1000, 2000, 3000, 5000];

    // Utility: safe text node creation
    function elText(tag, text, cls){
        const el = document.createElement(tag);
        if (cls) el.className = cls;
        el.textContent = (text === undefined || text === null) ? '' : String(text);
        return el;
    }

    // Try fetching from multiple paths in order
    async function fetchAny(paths){
        for (const p of paths){
            try {
                const res = await fetch(p, {cache: "no-store"});
                if (!res.ok) continue;
                const json = await res.json();
                return json;
            } catch(e){
                console.warn('fetch failed for', p, e);
            }
        }
        throw new Error('recipes.json を見つけられませんでした。期待する場所: ' + paths.join(', '));
    }

    // Normalize and flatten recipes + preparations into an array for table
    function buildFlatList(data){
        const list = [];
        if (!data || typeof data !== 'object') return list;

        const recipes = data.recipes || {};
        for (const key of Object.keys(recipes)){
            const item = Object.assign({}, recipes[key]);
            item._type = 'recipe';
            item.No = item.No != null ? String(item.No) : String(key);
            item._origKey = key;
            list.push(item);
        }
        const pres = data.preparations || {};
        for (const key of Object.keys(pres)){
            const item = Object.assign({}, pres[key]);
            item._type = 'pre';
            item.No = item.No != null ? String(item.No) : String(key);
            item._origKey = key;
            list.push(item);
        }
        return list;
    }

    // safe join array-like fields for display
    function joinIfArray(val){
        if (Array.isArray(val)) return val.join(', ');
        if (val === undefined || val === null) return '';
        return String(val);
    }

    function clearTable(){ 
        if(tbody) tbody.innerHTML = ''; 
    }

    /**
     * チェックボックスグループを生成するヘルパー関数
     */
    function createCheckboxGroup(title, key, values, hintText = '', labels = null) {
        const fieldset = document.createElement('fieldset');
        fieldset.className = 'filter-group';
        fieldset.style.border = '1px solid #ccc'; 
        fieldset.style.margin = '10px 0';
        fieldset.style.padding = '15px';
        fieldset.style.borderRadius = '4px';

        const legend = document.createElement('legend');
        legend.textContent = title;
        legend.style.fontWeight = 'bold';
        legend.style.padding = '0 10px';
        fieldset.appendChild(legend);

        if (hintText) {
             const hint = elText('p', hintText, 'filter-hint');
             hint.style.fontSize = '0.9em';
             hint.style.color = '#555';
             fieldset.appendChild(hint);
        }

        values.forEach((value, index) => {
            const strValue = String(value);
            const id = `${key}-${strValue.replace(/[^a-zA-Z0-9]/g, '-')}`;
            const labelText = labels ? labels[index] : strValue;

            const div = document.createElement('div');
            div.className = 'filter-item';
            div.style.display = 'inline-block';
            div.style.marginRight = '20px';
            div.style.marginBottom = '5px';

            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.id = id;
            checkbox.value = strValue;
            checkbox.dataset.filterKey = key;
            // フィルタ状態を復元
            if (activeFilters[key] && activeFilters[key].has(strValue)) {
                checkbox.checked = true;
            }

            const label = document.createElement('label');
            label.htmlFor = id;
            label.textContent = labelText;

            div.appendChild(checkbox);
            div.appendChild(label);
            fieldset.appendChild(div);
        });
        return fieldset;
    }

    /**
     * フィルターモーダルの設定とチェックボックスの生成
     * @param {Array} list - flatList
     */
    function setupFilterModal(list){
        if (!filterContent) return; 

        filterContent.innerHTML = '';
        const fragment = document.createDocumentFragment();

        // ------------------------------------
        // 1. 魚種フィルター (fish-name) - 複数選択
        // ------------------------------------
        const fishSet = new Set();
        list.forEach(item => {
            if (item._type === 'recipe' && Array.isArray(item['fish-name'])) {
                item['fish-name'].forEach(fish => {
                    const trimmedFish = fish.trim();
                    if (trimmedFish) fishSet.add(trimmedFish);
                });
            }
        });
        const uniqueFish = Array.from(fishSet).sort();
        fragment.appendChild(createCheckboxGroup('魚種', 'fish-name', uniqueFish, '選択した魚種のいずれかを含むレシピを表示'));

        // ------------------------------------
        // 2. 難易度フィルター (difficulty) - 「以下」で絞り込み
        // ------------------------------------
        fragment.appendChild(createCheckboxGroup('難易度', 'difficulty', DIFFICULTY_OPTIONS, 'チェックした難易度以下のレシピを表示', DIFFICULTY_OPTIONS.map(d => `難易度 ${d} 以下`)));

        // ------------------------------------
        // 3. 所要時間フィルター (time) - 「以下」で絞り込み
        // ------------------------------------
        fragment.appendChild(createCheckboxGroup('所要時間 (分)', 'time', TIME_OPTIONS, 'チェックした時間以下のレシピを表示 (最も短いチェックが適用されます)', TIME_OPTIONS.map(t => `${t}分以内`)));

        // ------------------------------------
        // 4. 費用フィルター (cost) - 「以下」で絞り込み
        // ------------------------------------
        fragment.appendChild(createCheckboxGroup('費用 (円)', 'cost', COST_OPTIONS, 'チェックした費用以下のレシピを表示 (最も安いチェックが適用されます)', COST_OPTIONS.map(c => `¥${c}以下`)));

        filterContent.appendChild(fragment);

        // イベントリスナーの再設定
        filterContent.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
            checkbox.addEventListener('change', updateActiveFilters);
        });
    }

    /**
     * チェックボックスの状態を activeFilters に反映する
     */
    function updateActiveFilters() {
        // 全てクリアしてから再構築
        activeFilters = {
            'fish-name': new Set(),
            difficulty: new Set(),
            time: new Set(),
            cost: new Set()
        };

        filterContent.querySelectorAll('input[type="checkbox"]:checked').forEach(checkbox => {
            const key = checkbox.dataset.filterKey;
            if (activeFilters[key]) {
                activeFilters[key].add(checkbox.value);
            }
        });
    }
    
    // render table rows from list
    function renderTable(list){
        clearTable();
        if (!tbody) return; 

        if (!Array.isArray(list) || list.length === 0){
            tbody.innerHTML = '<tr><td colspan="8" class="muted" style="padding:20px;text-align:center">表示するレシピがありません。</td></tr>';
            return;
        }
        const fragment = document.createDocumentFragment();
        for (const item of list){
            const tr = document.createElement('tr');

            // No
            const tdNo = document.createElement('td');
            tdNo.textContent = item.No || '-';
            tr.appendChild(tdNo);

            // Type
            const tdType = document.createElement('td');
            const span = document.createElement('span');
            span.className = 'tag-type ' + (item._type === 'pre' ? 'type-pre' : 'type-recipe');
            span.textContent = item._type;
            tdType.appendChild(span);
            tr.appendChild(tdType);

            // Picture
            const tdPicture = document.createElement('td');
            const img = document.createElement('img');
            img.className = 'recipe-thumb';
            const firstPic = (Array.isArray(item.pictures) && item.pictures.length > 0) ? item.pictures[0] : null;
            let imgSrc = firstPic && typeof firstPic === 'string' ? firstPic : 'https://0128-game.github.io/Fish-recipe/picture/noimage.png';
            img.src = imgSrc;
            img.alt = item.title || '画像';
            img.style.width = '80px'; 
            img.style.height = '60px'; 
            img.style.objectFit = 'cover'; 
            tdPicture.appendChild(img);
            tr.appendChild(tdPicture);

            // Title and flavortxt
            const tdTitle = document.createElement('td');
            const title = elText('div', item.title || '(タイトルなし)', ''); title.style.fontWeight='700';
            const flav = elText('div', item.flavortxt || '', 'muted');
            tdTitle.appendChild(title);
            tdTitle.appendChild(flav);
            tr.appendChild(tdTitle);

            // fish / season
            const tdFish = document.createElement('td');
            tdFish.appendChild(elText('div', joinIfArray(item['fish-name']) || '-', ''));
            tdFish.appendChild(elText('div', joinIfArray(item.season) || '', 'muted'));
            tr.appendChild(tdFish);

            // difficulty / time
            const tdDiff = document.createElement('td');
            tdDiff.appendChild(elText('div', '難易度: ' + (item.difficulty != null ? item.difficulty : '-')));
            tdDiff.appendChild(elText('div', '所要: ' + (item.time != null ? item.time + '分' : '-'), 'muted'));
            tr.appendChild(tdDiff);

            // cost / info line
            const tdCost = document.createElement('td');
            tdCost.appendChild(elText('div', '¥' + (item.cost != null ? item.cost : '-')));
            const infoLine = (item._type === 'recipe')
                ? ('食事: ' + (item.timing || '-'))
                : ('特徴: ' + joinIfArray(item.feature));
            tdCost.appendChild(elText('div', infoLine, 'muted'));
            tr.appendChild(tdCost);

            // actions
            const tdActions = document.createElement('td');
            tdActions.className = 'actions';

            // 詳細ボタン
            const viewBtn = document.createElement('button');
            viewBtn.textContent = '詳細';
            viewBtn.addEventListener('click', ()=> {
                displayDetail(item);
            });
            tdActions.appendChild(viewBtn);

            // 印刷ボタン
            const printBtn = document.createElement('button');
            printBtn.textContent = '印刷';
            printBtn.style.background = '#a0aec0'; 
            printBtn.addEventListener('click', ()=> {
                displayDetail(item);
                setTimeout(() => {
                    window.print();
                }, 500); 
            });
            tdActions.appendChild(printBtn);

            tr.appendChild(tdActions);
            fragment.appendChild(tr);
        }
        tbody.appendChild(fragment);
    }
    
    // Utility: 画像を表示するエレメントを作成する関数
    function createPictureElement(src, altText, maxHeight = '250px') {
        if (!src || src === 'null' || src === '') return null;

        const img = document.createElement('img');
        img.src = src;
        img.alt = altText || '画像';

        img.style.maxWidth = '100%';
        img.style.maxHeight = maxHeight;
        img.style.width = 'auto';
        img.style.objectFit = 'contain';
        img.style.borderRadius = '4px';
        img.style.display = 'block';
        img.style.margin = '0 auto';

        return img;
    }

    // 詳細情報を表示する関数 (元のコードを維持)
    function displayDetail(item){
        if(!detailTitle || !detailSubtitle || !detailMeta || !detailImageContainer || !detailIngredients || !detailRecipe || !detailMemo || !propsSection) {
            console.error("Missing detail element(s) in HTML.");
            return;
        }

        if (wrap) {
            wrap.classList.remove('list-view');
            wrap.classList.add('detail-view');
        }
        window.scrollTo({ top: 0, behavior: 'smooth' });

        const pictures = item.pictures || [];
        const thumbPic = pictures[0] || 'https://0128-game.github.io/Fish-recipe/picture/noimage.png';

        detailTitle.textContent = (item.title || '(タイトルなし)') + ' — No.' + item.No;
        detailSubtitle.textContent = item.flavortxt || '';

        detailMeta.innerHTML = '';
        detailMeta.appendChild(elText('div', 'タイプ: ' + (item._type || '-'), 'pill'));
        detailMeta.appendChild(elText('div', '魚: ' + joinIfArray(item['fish-name']) , 'pill'));
        detailMeta.appendChild(elText('div', '旬: ' + joinIfArray(item.season), 'pill'));
        detailMeta.appendChild(elText('div', '難易度: ' + (item.difficulty != null ? item.difficulty : '-'), 'pill'));
        detailMeta.appendChild(elText('div', '費用: ' + (item.cost != null ? '¥' + item.cost : '-'), 'pill'));
        detailMeta.appendChild(elText('div', '所要時間: ' + (item.time != null ? item.time + '分' : '-'), 'pill'));

        if (item._type === 'recipe') {
            const preRecipeNo = item['pre-recipe'] ? String(item['pre-recipe']) : null;

            if (preRecipeNo) {
                const preItem = flatList.find(i => i._type === 'pre' && String(i.No) === preRecipeNo);

                if (preItem) {
                    const preBtn = document.createElement('button');
                    preBtn.textContent = '下処理: ' + (preItem.title || preItem.No); 
                    preBtn.className = 'pill pre-link-pill';
                    preBtn.style.cursor = 'pointer'; 

                    preBtn.addEventListener('click', ()=> displayDetail(preItem)); 
                    detailMeta.appendChild(preBtn);
                } else {
                    detailMeta.appendChild(elText('div', '下処理: No.' + preRecipeNo + ' (未発見)', 'pill'));
                }
            } else {
                 detailMeta.appendChild(elText('div', '下処理: なし', 'pill'));
            }
        } else if (item._type === 'pre') {
             detailMeta.appendChild(elText('div', '下処理', 'pill'));
        }

        detailImageContainer.innerHTML = '';
        const mainImg = createPictureElement(thumbPic, item.title, '250px');
        if (mainImg) {
            mainImg.style.border = '1px solid #ddd';
            mainImg.style.borderRadius = '8px';
            detailImageContainer.appendChild(mainImg);
        }

        detailIngredients.innerHTML = '';
        const ing = item.ingredients || {};

        if (Object.keys(ing).length === 0){
            detailIngredients.appendChild(elText('div','(材料なし)','muted'));
        } else {
            const ul = document.createElement('ul');
            for (const k of Object.keys(ing)){
                const li = document.createElement('li');
                li.textContent = k + ': ' + (ing[k] || '');
                ul.appendChild(li);
            }
            detailIngredients.appendChild(ul);
        }

        detailProps.innerHTML = '';
        const props = item.props || {};

        if (item._type === 'pre') {
            if (propsSection) propsSection.style.display = 'block';

            if (Object.keys(props).length === 0){
                detailProps.appendChild(elText('div', '(道具なし)', 'muted'));
            } else {
                const ul = document.createElement('ul');
                for (const k of Object.keys(props)){
                    const li = document.createElement('li');
                    li.textContent = props[k] || '';
                    ul.appendChild(li);
                }
                detailProps.appendChild(ul);
            }
        } else {
            if (propsSection) propsSection.style.display = 'none';
        }

        detailRecipe.innerHTML = '';
        const rec = item.recipe || [];

        if (!Array.isArray(rec) || rec.length === 0){
            detailRecipe.appendChild(elText('div','(手順なし)','muted'));
        } else {
            const gridContainer = document.createElement('div');
            gridContainer.style.display = 'grid';
            gridContainer.style.gridTemplateColumns = 'repeat(auto-fit, minmax(280px, 1fr))';
            gridContainer.style.gap = '10px';
            
            for (let i = 0; i < rec.length; i++){
                const step = rec[i];
                const stepNo = i + 1;

                const card = document.createElement('div');
                card.className = 'recipe-step-card'; 
                card.style.border = '1px solid #ddd'; 
                card.style.padding = '10px';
                card.style.margin = '5px';

                const stepPicIndex = i + 1;
                const stepPicSrc = pictures[stepPicIndex];

                if (stepPicSrc && stepPicSrc !== 'null' && stepPicSrc !== '') {
                    const picContainer = document.createElement('div');
                    picContainer.className = 'recipe-step-picture';
                    const stepImg = createPictureElement(stepPicSrc, `手順${stepNo}の画像`, '150px');

                    if (stepImg) {
                        picContainer.appendChild(stepImg);
                        card.appendChild(picContainer);
                    }
                }

                const p = document.createElement('p');
                p.innerHTML = `<span style="font-weight:bold; color:#007bff;">${stepNo}.</span> ${step}`;
                card.appendChild(p);

                gridContainer.appendChild(card);
            }
            
            detailRecipe.appendChild(gridContainer);
        }

        detailMemo.innerHTML = '';
        const memo = item.memo || [];
        if (!Array.isArray(memo) || memo.length === 0){
            detailMemo.appendChild(elText('div','(メモなし)','muted'));
        } else {
            const ulm = document.createElement('ul');
            for (const m of memo){
                ulm.appendChild(elText('li', m));
            }
            detailMemo.appendChild(ulm);
        }
    }


    /**
     * フィルターを適用し、テーブルを再描画する (モーダルチェックボックス対応版)
     */
    function applyFiltersAndRender(){
        // 必須要素の存在チェック
        if(!qInput || !filterType || !sortBy || !message) {
             console.error("Missing CORE filter element(s) in HTML.");
             return;
        }

        const q = (qInput.value || '').trim().toLowerCase();
        const type = filterType.value;
        const sortVal = sortBy.value;

        let list = flatList.slice();

        // 1. タイプのフィルター
        if (type !== 'all') list = list.filter(i => i._type === type);

        // 2. 検索 (Search)
        if (q){
            list = list.filter(item => {
                const parts = [
                    item.title, item.flavortxt,
                    joinIfArray(item['fish-name']),
                    joinIfArray(item.feature),
                    joinIfArray(item.season),
                    item.No,
                    Object.keys(item.ingredients || {}).join(' '),
                    joinIfArray(item.recipe),
                    joinIfArray(item.memo),
                    joinIfArray(item.props)
                ];
                const hay = parts.filter(Boolean).join(' ').toLowerCase();
                return hay.includes(q);
            });
        }

        // ★★★ 3. チェックボックスによる統合されたフィルターロジックの適用 ★★★
        list = list.filter(item => {
            // 下処理アイテムはレシピ固有のフィルター対象外
            if (item._type === 'pre') return true;

            // --- 魚種フィルター (fish-name) - OR条件 ---
            const activeFish = activeFilters['fish-name'];
            if (activeFish.size > 0) {
                const itemFish = Array.isArray(item['fish-name']) ? item['fish-name'].map(f => f.trim()) : [];
                // 選択された魚種のどれか一つでもレシピに含まれていればOK
                const match = itemFish.some(f => activeFish.has(f));
                if (!match) return false;
            }

            // --- 難易度フィルター (difficulty) - MINIMUM MAX値条件 ---
            const activeDiff = activeFilters.difficulty;
            if (activeDiff.size > 0) {
                // 選択された値の中で「最も厳しい（小さい）」難易度を抽出 (難易度はこの値以下で絞るため)
                const minRequiredMaxDiff = Math.min(...Array.from(activeDiff).map(v => parseFloat(v)));
                const itemDiff = parseFloat(item.difficulty);
                
                // difficultyが設定されている場合のみ比較
                if (item.difficulty != null) {
                    if (itemDiff > minRequiredMaxDiff) return false;
                }
            }

            // --- 所要時間フィルター (time) - MINIMUM MAX値条件 ---
            const activeTime = activeFilters.time;
            if (activeTime.size > 0) {
                // 選択された値の中で「最も短い」時間 (maxTime) を抽出
                const minMaxTime = Math.min(...Array.from(activeTime).map(v => parseFloat(v)));
                const itemTime = parseFloat(item.time);

                if (item.time != null) {
                    if (itemTime > minMaxTime) return false;
                }
            }
            
            // --- 費用フィルター (cost) - MINIMUM MAX値条件 ---
            const activeCost = activeFilters.cost;
            if (activeCost.size > 0) {
                // 選択された値の中で「最も安い」金額 (maxCost) を抽出
                const minMaxCost = Math.min(...Array.from(activeCost).map(v => parseFloat(v)));
                const itemCost = parseFloat(item.cost);

                if (item.cost != null) {
                    if (itemCost > minMaxCost) return false;
                }
            }

            return true;
        });
        // ★★★ フィルタリングロジックの適用 ここまで ★★★


        // 4. ソート (Sort)
        const desc = sortVal.startsWith('-');
        const key = desc ? sortVal.slice(1) : sortVal;

        list.sort((a,b)=>{
            const av = a[key];
            const bv = b[key];

            if (key === 'No'){
                const extractNum = (val) => {
                    const s = String(val||'');
                    const isPre = s.startsWith('P');
                    const num = parseInt(s.replace(/^P/,'') || '0', 10);
                    return isPre ? num + 0.5 : num;
                };
                const na = extractNum(av);
                const nb = extractNum(bv);
                return desc ? nb - na : na - nb;
            }

            const an = (av == null) ? Number.POSITIVE_INFINITY : Number(av);
            const bn = (bv == null) ? Number.POSITIVE_INFINITY : Number(bv);
            if (!isFinite(an) || !isFinite(bn)){
                return desc ? String(bv).localeCompare(String(av)) : String(av).localeCompare(String(bv));
            }
            return desc ? bn - an : an - bn;
        });


        renderTable(list);
        
        let activeCount = 0;
        for (const key in activeFilters) {
             activeCount += activeFilters[key].size;
        }

        let filterText = '';
        if (activeCount > 0) {
             filterText = ` (${activeCount} 種類のフィルター適用中)`;
        }

        message.textContent = `${list.length} 件の結果を表示中 (全 ${flatList.length} 件)${filterText}`;
    }

    // reload button
    if(reloadBtn) {
        reloadBtn.addEventListener('click', ()=> {
            loadData();
        });
    }

    // リストに戻るボタンのイベントリスナー
    if(backToListBtn) {
        backToListBtn.addEventListener('click', ()=> {
            if(wrap) {
                wrap.classList.remove('detail-view');
                wrap.classList.add('list-view');
            }
            window.scrollTo({ top: 0, behavior: 'smooth' });
        });
    }

    // フィルターと検索のイベントリスナー
    if(qInput) qInput.addEventListener('input', ()=> applyFiltersAndRender());
    if(filterType) filterType.addEventListener('change', ()=> applyFiltersAndRender());
    if(sortBy) sortBy.addEventListener('change', ()=> applyFiltersAndRender());
    
    // ★★★ フィルターモーダル関連のイベントリスナー ★★★
    if (filterOpenBtn) {
        filterOpenBtn.addEventListener('click', () => {
             // モーダル表示時に毎回チェックボックスの状態を更新し、表示をリフレッシュ
             setupFilterModal(flatList); 
             if (filterModal) filterModal.style.display = 'flex'; // flexで表示
        });
        
        // モーダルのオーバーレイをクリックで閉じる (簡易的なもの)
        if (filterModal) {
            filterModal.addEventListener('click', (e) => {
                if (e.target === filterModal) {
                    filterModal.style.display = 'none';
                }
            });
        }
    }

    if (applyFilterBtn) {
        applyFilterBtn.addEventListener('click', () => {
             updateActiveFilters(); // チェックボックスの状態を確定
             applyFiltersAndRender();
             if (filterModal) filterModal.style.display = 'none'; // モーダルを閉じる
        });
    }
    
    if (filterClearBtn) {
        filterClearBtn.addEventListener('click', () => {
             // 全てのフィルターをクリア
             activeFilters = {
                'fish-name': new Set(),
                difficulty: new Set(),
                time: new Set(),
                cost: new Set()
             };
             // UIをリセットするために再度セットアップ
             setupFilterModal(flatList); 
             applyFiltersAndRender();
        });
    }
    // ★★★ フィルターモーダル関連のイベントリスナー ここまで ★★★


    // main loader
    async function loadData(){
        if(message) message.textContent = '読み込み中...';
        try {
            const json = await fetchAny(tryPaths);
            rawData = json;
            flatList = buildFlatList(json);

            if (flatList.length === 0){
                if(message) message.innerHTML = '<div class="notice">recipes または preparations のデータが空です。docs/recipes.json を確認してください。</div>';
            } else {
                if(message) message.textContent = `読み込み完了 — 合計 ${flatList.length} 件（recipes: ${Object.keys(json.recipes||{}).length}, preparations: ${Object.keys(json.preparations||{}).length}）`;
            }
            
            // 初回表示
            applyFiltersAndRender();
            if(wrap) {
                 wrap.classList.remove('detail-view');
                 wrap.classList.add('list-view');
            }
        } catch (err){
            console.error(err);
            if(message) message.innerHTML = '<div class="notice">読み込みエラー: ' + String(err.message) + '</div>';
            clearTable();
            if(wrap) wrap.classList.remove('detail-view');
        }
    }

    // initial load
    loadData();

    // Expose for debug on window
    window._recipesApp = {
        loadData,
        getRaw: ()=> rawData,
        getFlat: ()=> flatList
    };
})();
</script>
</body>
</html>
