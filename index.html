(function() {
    // =========================================================================
    // 1. 初期変数とダミー定義 (コードの動作に必要な仮の定義)
    // =========================================================================
    
    // グローバルなデータストア
    let rawData = null;
    let flatList = [];
    let activeFilters = {
        'fish-name': new Set(),
        difficulty: null,
        time: null,
        cost: null
    };

    // フィルターのオプション（ダミーデータ）
    const DIFFICULTY_OPTIONS = [1, 3, 5];
    const TIME_OPTIONS = [10, 30, 60];
    const TIME_MAX = 120;
    const COST_OPTIONS = [500, 1000, 2000];
    const COST_MAX = 5000;
    const tryPaths = ['/docs/data.json']; // ダミーのデータパス

    // DOM elements (実際にはHTMLでIDを定義する必要があります)
    const getEl = (id) => document.getElementById(id);
    const wrap = getEl('wrap');
    const tbody = getEl('tbody');
    const qInput = getEl('qInput');
    const filterType = getEl('filterType');
    const sortBy = getEl('sortBy');
    const message = getEl('message');
    const reloadBtn = getEl('reloadBtn');
    const backToListBtn = getEl('backToListBtn');
    const detailTitle = getEl('detailTitle');
    const detailSubtitle = getEl('detailSubtitle');
    const detailMeta = getEl('detailMeta');
    const detailImageContainer = getEl('detailImageContainer');
    const detailIngredients = getEl('detailIngredients');
    const detailRecipe = getEl('detailRecipe');
    const detailMemo = getEl('detailMemo');
    const propsSection = getEl('propsSection');
    const detailProps = getEl('detailProps');
    
    // フィルターモーダル関連
    const filterOpenBtn = getEl('filterOpenBtn');
    const applyFilterBtn = getEl('applyFilterBtn');
    const filterClearBtn = getEl('filterClearBtn');
    const filterContent = getEl('filterContent');
    const filterModal = getEl('filterModal');
    
    // ★★★ 料理提案モーダル関連（追加） ★★★
    const suggestionOpenBtn = getEl('suggestionOpenBtn');
    const suggestionModal = getEl('suggestionModal');
    // ★★★ 料理提案モーダル関連（追加） ここまで ★★★


    // =========================================================================
    // 2. ユーティリティ関数 (元のコードで使われているが定義がなかったもの)
    // =========================================================================

    // 配列を結合して文字列にする（null, undefined, 空配列に対応）
    function joinIfArray(arr) {
        if (Array.isArray(arr) && arr.length > 0) {
            return arr.join(', ');
        }
        if (typeof arr === 'object' && arr !== null) { // オブジェクトの場合
            return Object.values(arr).join(', ');
        }
        return '';
    }

    // テキスト要素を作成する（ダミー）
    function elText(tag, text, className = '') {
        const el = document.createElement(tag);
        el.textContent = text;
        if (className) el.className = className;
        return el;
    }

    // テーブルをクリアする（ダミー）
    function clearTable() {
        if (tbody) tbody.innerHTML = '';
    }

    // データを取得する（ダミー）
    async function fetchAny(paths) {
        console.log(`ダミーデータを取得中: ${paths[0]}`);
        // 実際のデータ構造に合わせてダミーデータを返却
        return {
            recipes: {
                "R01": { No: "R01", _type: "recipe", title: "サバの味噌煮", flavortxt: "定番の煮物", difficulty: 2, time: 25, cost: 800, "fish-name": ["サバ"], season: ["秋", "冬"], ingredients: { "サバ": "2切れ", "味噌": "大さじ3" }, recipe: ["サバを下処理する", "調味料で煮込む"], memo: ["ご飯によく合う"], pictures: ['pic/saba1.jpg', 'pic/saba2.jpg'] },
            },
            preparations: {
                "P01": { No: "P01", _type: "pre", title: "サバの3枚おろし", flavortxt: "下処理の基本", difficulty: 3, time: 15, cost: 0, "fish-name": ["サバ", "イワシ"], season: ["通年"], ingredients: {}, recipe: ["ウロコを取る", "頭を落とす", "3枚におろす"], memo: ["骨に注意"], props: { "包丁": "出刃", "まな板": "大" }, pictures: ['pic/pre1.jpg', 'pic/pre2.jpg'] },
            }
        };
    }

    // 取得したデータをフラットリストに変換する（ダミー）
    function buildFlatList(data) {
        const list = [];
        if (data.recipes) {
            Object.values(data.recipes).forEach(item => list.push(item));
        }
        if (data.preparations) {
            Object.values(data.preparations).forEach(item => list.push(item));
        }
        return list;
    }
    
    // チェックボックスグループを作成する（ダミー）
    function createCheckboxGroup(title, key, options, hint) {
        const container = document.createElement('div');
        container.innerHTML = `<h4>${title}</h4><small class="muted">${hint}</small>`;
        options.forEach(val => {
            const label = document.createElement('label');
            label.innerHTML = `<input type="checkbox" value="${val}" data-filter-key="${key}"> ${val}`;
            container.appendChild(label);
        });
        return container;
    }

    // ラジオボタン/入力グループを作成する（ダミー）
    function createRadioGroup(title, key, options, hint, labels, customType, customProps) {
        const container = document.createElement('div');
        container.innerHTML = `<h4>${title}</h4><small class="muted">${hint}</small>`;

        // 制限なしオプション
        let label = document.createElement('label');
        label.innerHTML = `<input type="radio" name="${key}" value="" data-filter-key="${key}" checked> 制限なし`;
        container.appendChild(label);

        // 定義済みオプション
        options.forEach((val, index) => {
            label = document.createElement('label');
            label.innerHTML = `<input type="radio" name="${key}" value="${val}" data-filter-key="${key}"> ${labels[index]}`;
            container.appendChild(label);
        });

        // カスタム入力オプション
        if (customType === 'radio-input') {
            label = document.createElement('label');
            label.innerHTML = `<input type="radio" name="${key}" value="CUSTOM" data-filter-key="${key}"> カスタム`;
            container.appendChild(label);

            const inputContainer = document.createElement('div');
            inputContainer.className = 'filter-input-container';
            inputContainer.style.display = 'none';
            const input = document.createElement('input');
            input.type = 'number';
            input.dataset.filterKey = key;
            input.dataset.inputType = 'custom';
            input.min = customProps.min;
            input.max = customProps.max;
            input.placeholder = `最大${title.includes('時間') ? '分' : '円'}`;
            inputContainer.appendChild(input);
            container.appendChild(inputContainer);
        }
        return container;
    }


    // =========================================================================
    // 3. 関数定義 (提供されたコードの配置)
    // =========================================================================

    /**
     * フィルターモーダルの設定とチェックボックス/ラジオボタンの生成
     * @param {Array} list - flatList
     */
     function setupFilterModal(list){
         if (!filterContent) return; 

         filterContent.innerHTML = '';
         const fragment = document.createDocumentFragment();

         // 1. 魚種フィルター (fish-name) - チェックボックス（複数選択）
         const fishSet = new Set();
         list.forEach(item => {
             if (Array.isArray(item['fish-name'])) { // pre/recipe 両方から魚種名を収集
                 item['fish-name'].forEach(fish => {
                     const trimmedFish = fish.trim();
                     if (trimmedFish) fishSet.add(trimmedFish);
                 });
             }
         });
         const uniqueFish = Array.from(fishSet).sort();
         // ユーザーにAND条件であることを示すヒントテキスト
         fragment.appendChild(createCheckboxGroup('魚種', 'fish-name', uniqueFish, 'レシピ/下処理に使う魚が、選択した魚種のすべてに含まれるものを表示 (b ⊆ a)'));

         // 2. 難易度フィルター (difficulty) - ラジオボタン（単一選択）
         fragment.appendChild(createRadioGroup('難易度 (最大)', 'difficulty', DIFFICULTY_OPTIONS, '選択した難易度以下のアイテムを表示', DIFFICULTY_OPTIONS.map(d => `難易度 ${d} 以下`)));

         // 3. 所要時間フィルター (time) - ラジオボタン＋カスタム入力欄
         fragment.appendChild(createRadioGroup('所要時間 (分・最大)', 'time', TIME_OPTIONS, '選択肢またはカスタム入力で指定した時間以下のアイテムを表示', TIME_OPTIONS.map(t => `${t}分以内`), 'radio-input', {min: 1, max: TIME_MAX}));

         // 4. 費用フィルター (cost) - ラジオボタン＋カスタム入力欄
         fragment.appendChild(createRadioGroup('費用 (円・最大)', 'cost', COST_OPTIONS, '選択肢またはカスタム入力で指定した費用以下のアイテムを表示', COST_OPTIONS.map(c => `¥${c}以下`), 'radio-input', {min: 100, max: COST_MAX}));

         filterContent.appendChild(fragment);

         // イベントリスナーの再設定
         filterContent.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
             checkbox.addEventListener('change', updateActiveFilters);
         });
         filterContent.querySelectorAll('input[type="radio"], input[type="number"]').forEach(input => {
             input.addEventListener('change', handleRadioInputChange);
             input.addEventListener('input', handleRadioInputChange);
         });
     }

    /**
     * ラジオボタン/入力欄の変更を処理し、入力欄の表示/非表示を制御する
     */
    function handleRadioInputChange(event) {
        const input = event.target;
        const key = input.dataset.filterKey;

        if (key === 'time' || key === 'cost') {
            const customContainer = filterContent.querySelector(`.filter-input-container input[data-filter-key="${key}"]`).parentNode;

            if (input.type === 'radio') {
                if (input.value === 'CUSTOM') {
                    customContainer.style.display = 'block';
                } else {
                    customContainer.style.display = 'none';
                    customContainer.querySelector('input[type="number"]').value = '';
                }
            }
        }
        
        updateActiveFilters();
    }


    /**
     * チェックボックス/ラジオボタン/入力欄の状態を activeFilters に反映する
     */
    function updateActiveFilters() {
        // fish-name は Setを再構築
        activeFilters['fish-name'].clear();
        filterContent.querySelectorAll('input[type="checkbox"]:checked').forEach(checkbox => {
            if (checkbox.dataset.filterKey === 'fish-name') {
                activeFilters['fish-name'].add(checkbox.value);
            }
        });
        
        // difficulty, time, cost は単一の値を設定
        ['difficulty', 'time', 'cost'].forEach(key => {
            activeFilters[key] = null; // まずリセット

            // 1. ラジオボタンの値を取得
            const checkedRadio = filterContent.querySelector(`input[type="radio"][name="${key}"]:checked`);
            if (checkedRadio) {
                if (checkedRadio.value === '') {
                    // 制限なし
                    activeFilters[key] = null;
                } else if (checkedRadio.value === 'CUSTOM') {
                    // カスタムが選択されている場合、入力欄の値を採用
                    const customInput = filterContent.querySelector(`input[type="number"][data-filter-key="${key}"][data-input-type="custom"]`);
                    const val = parseFloat(customInput.value);
                    if (!isNaN(val) && val > 0) {
                        activeFilters[key] = String(val);
                    }
                } else {
                    // 定義済みオプション
                    activeFilters[key] = checkedRadio.value;
                }
            }
        });
    }
    
    // render table rows from list
    function renderTable(list){
        clearTable();
        if (!tbody) return; 

        if (!Array.isArray(list) || list.length === 0){
            tbody.innerHTML = '<tr><td colspan="8" class="muted" style="padding:20px;text-align:center">表示するレシピがありません。</td></tr>';
            return;
        }
        const fragment = document.createDocumentFragment();
        for (const item of list){
            const tr = document.createElement('tr');

            // No
            const tdNo = document.createElement('td');
            tdNo.textContent = item.No || '-';
            tr.appendChild(tdNo);

            // Type
            const tdType = document.createElement('td');
            const span = document.createElement('span');
            span.className = 'tag-type ' + (item._type === 'pre' ? 'type-pre' : 'type-recipe');
            span.textContent = item._type;
            tdType.appendChild(span);
            tr.appendChild(tdType);

            // Picture
            const tdPicture = document.createElement('td');
            const img = document.createElement('img');
            img.className = 'recipe-thumb';
            const firstPic = (Array.isArray(item.pictures) && item.pictures.length > 0) ? item.pictures[0] : null;
            let imgSrc = firstPic && typeof firstPic === 'string' ? firstPic : 'https://0128-game.github.io/Fish-recipe/picture/noimage.png';
            img.src = imgSrc;
            img.alt = item.title || '画像';
            img.style.width = '80px'; 
            img.style.height = '60px'; 
            img.style.objectFit = 'cover'; 
            tdPicture.appendChild(img);
            tr.appendChild(tdPicture);

            // Title and flavortxt
            const tdTitle = document.createElement('td');
            const title = elText('div', item.title || '(タイトルなし)', ''); title.style.fontWeight='700';
            const flav = elText('div', item.flavortxt || '', 'muted');
            tdTitle.appendChild(title);
            tdTitle.appendChild(flav);
            tr.appendChild(tdTitle);

            // fish / season
            const tdFish = document.createElement('td');
            tdFish.appendChild(elText('div', joinIfArray(item['fish-name']) || '-', ''));
            tdFish.appendChild(elText('div', joinIfArray(item.season) || '', 'muted'));
            tr.appendChild(tdFish);

            // difficulty / time
            const tdDiff = document.createElement('td');
            tdDiff.appendChild(elText('div', '難易度: ' + (item.difficulty != null ? item.difficulty : '-')));
            tdDiff.appendChild(elText('div', '所要: ' + (item.time != null ? item.time + '分' : '-'), 'muted'));
            tr.appendChild(tdDiff);

            // cost / info line
            const tdCost = document.createElement('td');
            tdCost.appendChild(elText('div', '¥' + (item.cost != null ? item.cost : '-')));
            const infoLine = (item._type === 'recipe')
                ? ('食事: ' + (item.timing || '-'))
                : ('特徴: ' + joinIfArray(item.feature));
            tdCost.appendChild(elText('div', infoLine, 'muted'));
            tr.appendChild(tdCost);

            // actions
            const tdActions = document.createElement('td');
            tdActions.className = 'actions';

            // 詳細ボタン
            const viewBtn = document.createElement('button');
            viewBtn.textContent = '詳細';
            viewBtn.addEventListener('click', ()=> {
                displayDetail(item);
            });
            tdActions.appendChild(viewBtn);

            // 印刷ボタン
            const printBtn = document.createElement('button');
            printBtn.textContent = '印刷';
            printBtn.style.background = '#a0aec0'; 
            printBtn.addEventListener('click', ()=> {
                displayDetail(item);
                setTimeout(() => {
                    window.print();
                }, 500); 
            });
            tdActions.appendChild(printBtn);

            tr.appendChild(tdActions);
            fragment.appendChild(tr);
        }
        tbody.appendChild(fragment);
    }
    
    // Utility: 画像を表示するエレメントを作成する関数
    function createPictureElement(src, altText, maxHeight = '250px') {
        if (!src || src === 'null' || src === '') return null;

        const img = document.createElement('img');
        img.src = src;
        img.alt = altText || '画像';

        img.style.maxWidth = '100%';
        img.style.maxHeight = maxHeight;
        img.style.width = 'auto';
        img.style.objectFit = 'contain';
        img.style.borderRadius = '4px';
        img.style.display = 'block';
        img.style.margin = '0 auto';

        return img;
    }

    // 詳細情報を表示する関数
    function displayDetail(item){
        if(!detailTitle || !detailSubtitle || !detailMeta || !detailImageContainer || !detailIngredients || !detailRecipe || !detailMemo || !propsSection) {
            console.error("Missing detail element(s) in HTML.");
            return;
        }

        if (wrap) {
            wrap.classList.remove('list-view');
            wrap.classList.add('detail-view');
        }
        window.scrollTo({ top: 0, behavior: 'smooth' });

        const pictures = item.pictures || [];
        const thumbPic = pictures[0] || 'https://0128-game.github.io/Fish-recipe/picture/noimage.png';

        detailTitle.textContent = (item.title || '(タイトルなし)') + ' — No.' + item.No;
        detailSubtitle.textContent = item.flavortxt || '';

        detailMeta.innerHTML = '';
        detailMeta.appendChild(elText('div', 'タイプ: ' + (item._type || '-'), 'pill'));
        detailMeta.appendChild(elText('div', '魚: ' + joinIfArray(item['fish-name']) , 'pill'));
        detailMeta.appendChild(elText('div', '旬: ' + joinIfArray(item.season), 'pill'));
        detailMeta.appendChild(elText('div', '難易度: ' + (item.difficulty != null ? item.difficulty : '-'), 'pill'));
        detailMeta.appendChild(elText('div', '費用: ' + (item.cost != null ? '¥' + item.cost : '-'), 'pill'));
        detailMeta.appendChild(elText('div', '所要時間: ' + (item.time != null ? item.time + '分' : '-'), 'pill'));

        if (item._type === 'recipe') {
            const preRecipeNo = item['pre-recipe'] ? String(item['pre-recipe']) : null;

            if (preRecipeNo) {
                const preItem = flatList.find(i => i._type === 'pre' && String(i.No) === preRecipeNo);

                if (preItem) {
                    const preBtn = document.createElement('button');
                    preBtn.textContent = '下処理: ' + (preItem.title || preItem.No); 
                    preBtn.className = 'pill pre-link-pill';
                    preBtn.style.cursor = 'pointer'; 

                    preBtn.addEventListener('click', ()=> displayDetail(preItem)); 
                    detailMeta.appendChild(preBtn);
                } else {
                    detailMeta.appendChild(elText('div', '下処理: No.' + preRecipeNo + ' (未発見)', 'pill'));
                }
            } else {
                 detailMeta.appendChild(elText('div', '下処理: なし', 'pill'));
            }
        } else if (item._type === 'pre') {
             detailMeta.appendChild(elText('div', '下処理', 'pill'));
        }

        detailImageContainer.innerHTML = '';
        const mainImg = createPictureElement(thumbPic, item.title, '250px');
        if (mainImg) {
            mainImg.style.border = '1px solid #ddd';
            mainImg.style.borderRadius = '8px';
            detailImageContainer.appendChild(mainImg);
        }

        detailIngredients.innerHTML = '';
        const ing = item.ingredients || {};

        if (Object.keys(ing).length === 0){
            detailIngredients.appendChild(elText('div','(材料なし)','muted'));
        } else {
            const ul = document.createElement('ul');
            for (const k of Object.keys(ing)){
                const li = document.createElement('li');
                li.textContent = k + ': ' + (ing[k] || '');
                ul.appendChild(li);
            }
            detailIngredients.appendChild(ul);
        }

        detailProps.innerHTML = '';
        const props = item.props || {};

        if (item._type === 'pre') {
            if (propsSection) propsSection.style.display = 'block';

            if (Object.keys(props).length === 0){
                detailProps.appendChild(elText('div', '(道具なし)', 'muted'));
            } else {
                const ul = document.createElement('ul');
                for (const k of Object.keys(props)){
                    const li = document.createElement('li');
                    li.textContent = props[k] || '';
                    ul.appendChild(li);
                }
                detailProps.appendChild(ul);
            }
        } else {
            if (propsSection) propsSection.style.display = 'none';
        }

        detailRecipe.innerHTML = '';
        const rec = item.recipe || [];

        if (!Array.isArray(rec) || rec.length === 0){
            detailRecipe.appendChild(elText('div','(手順なし)','muted'));
        } else {
            const gridContainer = document.createElement('div');
            gridContainer.style.display = 'grid';
            gridContainer.style.gridTemplateColumns = 'repeat(auto-fit, minmax(280px, 1fr))';
            gridContainer.style.gap = '10px';
            
            for (let i = 0; i < rec.length; i++){
                const step = rec[i];
                const stepNo = i + 1;

                const card = document.createElement('div');
                card.className = 'recipe-step-card'; 
                card.style.border = '1px solid #dee2e6'; 
                card.style.padding = '15px';
                card.style.borderRadius = '6px';
                card.style.background = 'var(--card)';
                card.style.boxShadow = '0 1px 3px rgba(0,0,0,0.05)';

                const stepPicIndex = i + 1;
                const stepPicSrc = pictures[stepPicIndex];

                if (stepPicSrc && stepPicSrc !== 'null' && stepPicSrc !== '') {
                    const picContainer = document.createElement('div');
                    picContainer.className = 'recipe-step-picture';
                    const stepImg = createPictureElement(stepPicSrc, `手順${stepNo}の画像`, '150px');

                    if (stepImg) {
                        picContainer.appendChild(stepImg);
                        card.appendChild(picContainer);
                    }
                }

                const p = document.createElement('p');
                p.innerHTML = `<span style="font-weight:bold; color:var(--accent);">${stepNo}.</span> ${step}`;
                card.appendChild(p);

                gridContainer.appendChild(card);
            }
            
            detailRecipe.appendChild(gridContainer);
        }

        detailMemo.innerHTML = '';
        const memo = item.memo || [];
        if (!Array.isArray(memo) || memo.length === 0){
            detailMemo.appendChild(elText('div','(メモなし)','muted'));
        } else {
            const ulm = document.createElement('ul');
            for (const m of memo){
                ulm.appendChild(elText('li', m));
            }
            detailMemo.appendChild(ulm);
        }
    }


    /**
     * フィルターを適用し、テーブルを再描画する
     */
    function applyFiltersAndRender(){
        if(!qInput || !filterType || !sortBy || !message) { return; }

        const q = (qInput.value || '').trim().toLowerCase();
        const type = filterType.value;
        const sortVal = sortBy.value;

        let list = flatList.slice();

        // 1. タイプのフィルター
        if (type !== 'all') list = list.filter(i => i._type === type);

        // 2. 検索 (Search)
        if (q){
            list = list.filter(item => {
                const parts = [
                    item.title, item.flavortxt,
                    joinIfArray(item['fish-name']),
                    joinIfArray(item.feature),
                    joinIfArray(item.season),
                    item.No,
                    Object.keys(item.ingredients || {}).join(' '),
                    joinIfArray(item.recipe),
                    joinIfArray(item.memo),
                    joinIfArray(item.props)
                ];
                const hay = parts.filter(Boolean).join(' ').toLowerCase();
                return hay.includes(q);
            });
        }

        // 3. フィルターロジックの適用
        list = list.filter(item => {
            // --- 魚種フィルター (fish-name) - AND条件 (b ⊆ a) ---
            const activeFish = activeFilters['fish-name']; // a: ユーザーが選択した魚種リスト (Set)
            if (activeFish.size > 0) {
                // b: レシピ/下処理で使われている魚種を取得し、整形
                const itemFish = Array.isArray(item['fish-name']) ? item['fish-name'].map(f => f.trim()) : [];
                
                // b ⊆ a のチェック: レシピ/下処理で使われている魚 (b) すべてが、ユーザーの選択肢 (a) に含まれているか？
                const allMatch = itemFish.every(f => activeFish.has(f));
                
                if (!allMatch) return false;
            }

            // --- 難易度フィルター (difficulty) - 最大値条件 ---
            const maxDiff = activeFilters.difficulty ? parseFloat(activeFilters.difficulty) : null;
            if (maxDiff !== null && item.difficulty != null) {
                const itemDiff = parseFloat(item.difficulty);
                if (!isNaN(itemDiff) && itemDiff > maxDiff) return false;
            }

            // --- 所要時間フィルター (time) - 最大値条件 ---
            const maxTime = activeFilters.time ? parseFloat(activeFilters.time) : null;
            if (maxTime !== null && item.time != null) {
                const itemTime = parseFloat(item.time);
                if (!isNaN(itemTime) && itemTime > maxTime) return false;
            }
            
            // --- 費用フィルター (cost) - 最大値条件 ---
            const maxCost = activeFilters.cost ? parseFloat(activeFilters.cost) : null;
            if (maxCost !== null && item.cost != null) {
                const itemCost = parseFloat(item.cost);
                if (!isNaN(itemCost) && itemCost > maxCost) return false;
            }

            return true;
        });

        // 4. ソート (Sort)
        const desc = sortVal.startsWith('-');
        const key = desc ? sortVal.slice(1) : sortVal;

        list.sort((a,b)=>{
            const av = a[key];
            const bv = b[key];

            if (key === 'No'){
                const extractNum = (val) => {
                    const s = String(val||'');
                    const isPre = s.startsWith('P');
                    const num = parseInt(s.replace(/^P/,'') || '0', 10);
                    return isPre ? num + 0.5 : num;
                };
                const na = extractNum(av);
                const nb = extractNum(bv);
                return desc ? nb - na : na - nb;
            }

            const an = (av == null) ? Number.POSITIVE_INFINITY : Number(av);
            const bn = (bv == null) ? Number.POSITIVE_INFINITY : Number(bv);
            if (!isFinite(an) || !isFinite(bn)){
                return desc ? String(bv).localeCompare(String(av)) : String(av).localeCompare(String(bv));
            }
            return desc ? bn - an : an - bn;
        });


        renderTable(list);
        
        let activeCount = activeFilters['fish-name'].size;
        ['difficulty', 'time', 'cost'].forEach(key => {
            if (activeFilters[key] !== null) activeCount++;
        });

        let filterText = '';
        if (activeCount > 0) {
             filterText = ` (${activeCount} 種類のフィルター適用中)`;
        }

        message.textContent = `${list.length} 件の結果を表示中 (全 ${flatList.length} 件)${filterText}`;
    }

    // =========================================================================
    // 4. イベントリスナーと初期化
    // =========================================================================

    // reload button
    if(reloadBtn) {
        reloadBtn.addEventListener('click', ()=> {
            loadData();
        });
    }

    // リストに戻るボタンのイベントリスナー
    if(backToListBtn) {
        backToListBtn.addEventListener('click', ()=> {
            if(wrap) {
                wrap.classList.remove('detail-view');
                wrap.classList.add('list-view');
            }
            window.scrollTo({ top: 0, behavior: 'smooth' });
        });
    }

    // フィルターと検索のイベントリスナー
    if(qInput) qInput.addEventListener('input', ()=> applyFiltersAndRender());
    if(filterType) filterType.addEventListener('change', ()=> applyFiltersAndRender());
    if(sortBy) sortBy.addEventListener('change', ()=> applyFiltersAndRender());
    
    // ★★★ フィルターモーダル関連のイベントリスナー ★★★
    if (filterOpenBtn) {
        filterOpenBtn.addEventListener('click', () => {
             // モーダル表示時に毎回チェックボックス/ラジオボタンの状態を更新し、表示をリフレッシュ
             setupFilterModal(flatList); 
             if (filterModal) filterModal.style.display = 'flex'; // flexで表示
        });
        
        // モーダルのオーバーレイをクリックで閉じる (簡易的なもの)
        if (filterModal) {
            filterModal.addEventListener('click', (e) => {
                if (e.target === filterModal) {
                    filterModal.style.display = 'none';
                }
            });
        }
    }

    if (applyFilterBtn) {
        applyFilterBtn.addEventListener('click', () => {
             updateActiveFilters(); // チェックボックス/ラジオボタン/入力欄の状態を確定
             applyFiltersAndRender();
             if (filterModal) filterModal.style.display = 'none'; // モーダルを閉じる
        });
    }
    
    if (filterClearBtn) {
        filterClearBtn.addEventListener('click', () => {
             // 全てのフィルターをクリア
             activeFilters = {
                 'fish-name': new Set(),
                 difficulty: null,
                 time: null,
                 cost: null
             };
             // UIをリセットするために再度セットアップ
             setupFilterModal(flatList); 
             applyFiltersAndRender();
        });
    }
    // ★★★ フィルターモーダル関連のイベントリスナー ここまで ★★★

    
    // ★★★ 料理提案モーダル関連のイベントリスナー (追記) ★★★
    if (suggestionOpenBtn) {
        suggestionOpenBtn.addEventListener('click', () => {
             console.log("料理提案ボタンが押されました。");
             if (suggestionModal) suggestionModal.style.display = 'flex'; // flexでモーダルを表示
        });
        
        // モーダルのオーバーレイをクリックで閉じる (簡易的なもの)
        if (suggestionModal) {
            suggestionModal.addEventListener('click', (e) => {
                if (e.target === suggestionModal) {
                    suggestionModal.style.display = 'none';
                }
            });
        }
    }
    // ★★★ 料理提案モーダル関連のイベントリスナー ここまで ★★★


    // main loader
    async function loadData(){
        if(message) message.textContent = '読み込み中...';
        try {
            const json = await fetchAny(tryPaths);
            rawData = json;
            flatList = buildFlatList(json);

            if (flatList.length === 0){
                if(message) message.innerHTML = '<div class="notice">recipes または preparations のデータが空です。docs/recipes.json を確認してください。</div>';
            } else {
                if(message) message.textContent = `読み込み完了 — 合計 ${flatList.length} 件（recipes: ${Object.keys(json.recipes||{}).length}, preparations: ${Object.keys(json.preparations||{}).length}）`;
            }
            
            // 初回表示
            applyFiltersAndRender();
            if(wrap) {
                 wrap.classList.remove('detail-view');
                 wrap.classList.add('list-view');
            }
        } catch (err){
            console.error(err);
            if(message) message.innerHTML = '<div class="notice">読み込みエラー: ' + String(err.message) + '</div>';
            clearTable();
            if(wrap) wrap.classList.remove('detail-view');
        }
    }

    // initial load
    loadData();

    // Expose for debug on window
    window._recipesApp = {
        loadData,
        getRaw: ()=> rawData,
        getFlat: ()=> flatList,
        activeFilters: activeFilters 
    };
})();
